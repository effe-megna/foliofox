/**
 * TODO:
 *
 * Events generated by other events, e.g Home Loan -> Mortgage Payment
 * Stock
 * Dividend
 *
 */

// LocalDate implementation - no timezones, just year/month/day
type LocalDate = { y: number; m: number; d: number };

const ld = (y: number, m: number, d: number): LocalDate => ({ y, m, d });

const fromJSDate = (d: Date): LocalDate =>
  ld(d.getFullYear(), d.getMonth() + 1, d.getDate());

const toKeyMonth = (d: LocalDate): string =>
  `${d.y.toString().padStart(4, "0")}-${d.m.toString().padStart(2, "0")}`;

const startOfMonthLD = (d: LocalDate): LocalDate => ld(d.y, d.m, 1);

const addMonthsLD = (d: LocalDate, delta: number): LocalDate => {
  const total = d.m - 1 + delta;
  const newY = d.y + Math.floor(total / 12);
  const newM = (((total % 12) + 12) % 12) + 1;
  return ld(newY, newM, d.d);
};

const compareLD = (a: LocalDate, b: LocalDate): number => {
  if (a.y !== b.y) return a.y - b.y;
  if (a.m !== b.m) return a.m - b.m;
  return a.d - b.d;
};

const isAfterLD = (a: LocalDate, b: LocalDate): boolean => compareLD(a, b) > 0;

const isBeforeLD = (a: LocalDate, b: LocalDate): boolean => compareLD(a, b) < 0;

const isSameDayLD = (a: LocalDate, b: LocalDate): boolean =>
  compareLD(a, b) === 0;

const isWithinIntervalLD = (
  d: LocalDate,
  range: { start: LocalDate; end: LocalDate },
): boolean => !isBeforeLD(d, range.start) && !isAfterLD(d, range.end);

// Scenario types
type Scenario = {
  name: string;
  events: Array<ScenarioEvent>;
};

type BaseEvent = {
  name: string;
  type: "income" | "expense";
  amount: number;
  metadata?: Record<string, string>;
};

type OneOffEvent = {
  tag: "one-off";
  date: LocalDate;
} & BaseEvent;

type RecurringEvent = {
  tag: "recurring";
  startDate: LocalDate;
  endDate: LocalDate | null;
  frequency: "monthly" | "yearly";
} & BaseEvent;

type ScenarioEvent = OneOffEvent | RecurringEvent;

const makeScenario = (input: {
  name: string;
  events: Array<ScenarioEvent>;
}): Scenario => input;

const isSameMonthLD = (a: LocalDate, b: LocalDate): boolean =>
  a.y === b.y && a.m === b.m;

const isEventActiveInMonth = (
  monthStart: LocalDate,
  event: ScenarioEvent,
): boolean => {
  switch (event.tag) {
    case "one-off": {
      return isSameMonthLD(monthStart, event.date);
    }

    case "recurring": {
      const evStart = startOfMonthLD(event.startDate);
      const evEnd = event.endDate
        ? startOfMonthLD(event.endDate)
        : ld(2999, 12, 31);

      switch (event.frequency) {
        case "monthly": {
          return isWithinIntervalLD(monthStart, {
            start: evStart,
            end: evEnd,
          });
        }

        case "yearly": {
          // For yearly events, check if the month is within the date range
          // and if the month/day matches the start date
          if (
            !isWithinIntervalLD(monthStart, {
              start: evStart,
              end: evEnd,
            })
          ) {
            return false;
          }
          // Check if this month matches the anniversary month
          return monthStart.m === event.startDate.m;
        }
      }
    }
  }
};

type CashflowEntry = {
  amount: number;
  events: ScenarioEvent[];
};

type Cashflow = Record<string, CashflowEntry>;

const toCashflow = (input: {
  scenario: Scenario;
  startDate: LocalDate;
  endDate: LocalDate;
}): { months: Cashflow } => {
  const { scenario, startDate, endDate } = input;

  const months: Cashflow = {};

  let currentMonth = startOfMonthLD(startDate);
  const finalMonth = startOfMonthLD(endDate);

  while (!isAfterLD(currentMonth, finalMonth)) {
    const key = toKeyMonth(currentMonth);
    months[key] = { amount: 0, events: [] };

    // Evaluate active events for this month
    for (const event of scenario.events) {
      if (isEventActiveInMonth(currentMonth, event)) {
        const value = event.type === "income" ? event.amount : -event.amount;
        months[key].amount += value;
        months[key].events.push(event);
      }
    }

    currentMonth = addMonthsLD(currentMonth, 1);
  }

  return { months };
};

const runScenario = (input: {
  scenario: Scenario;
  startDate: LocalDate;
  endDate: LocalDate;
  initialBalance: number;
}): {
  cashflow: Cashflow;
  balance: Record<string, number>;
} => {
  const { scenario, startDate, endDate, initialBalance } = input;

  const { months: cashflow } = toCashflow({ scenario, startDate, endDate });

  const balance: Record<string, number> = {};

  let runningBalance = initialBalance;

  const sortedMonths = Object.keys(cashflow).sort();

  for (const month of sortedMonths) {
    runningBalance += cashflow[month].amount;
    balance[month] = runningBalance;
  }

  return { cashflow, balance };
};

const makeOneOff = (input: {
  type: "income" | "expense";
  name: string;
  amount: number;
  date: LocalDate;
}): ScenarioEvent => {
  return {
    type: input.type,
    amount: input.amount,
    tag: "one-off",
    date: input.date,
    name: input.name,
  };
};

const makeRecurring = (input: {
  type: "income" | "expense";
  name: string;
  amount: number;
  startDate: LocalDate;
  endDate: LocalDate | null;
  frequency: "monthly" | "yearly";
}): ScenarioEvent => {
  return {
    type: input.type,
    amount: input.amount,
    tag: "recurring",
    startDate: input.startDate,
    endDate: input.endDate,
    frequency: input.frequency,
    name: input.name,
  };
};

export {
  type LocalDate,
  type Scenario,
  type ScenarioEvent,
  ld,
  fromJSDate,
  makeScenario,
  toCashflow,
  runScenario,
  makeOneOff,
  makeRecurring,
  isEventActiveInMonth,
};
