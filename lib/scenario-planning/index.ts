/**
 * TODO:
 *
 * - Events generated by other events, e.g Home Loan -> Mortgage Payment
 * - Stock
 * - Dividend
 * - Move LocalDate implementation to a separate file
 * - Introduce AND and OR logic to conditions
 */

import {
  LocalDate,
  isAfterLD,
  addMonthsLD,
  startOfMonthLD,
  toKeyMonth,
  ld,
  isWithinIntervalLD,
} from "./local-date";
import { makeDependency } from "./helpers";
import type { PortfolioAsset, AssetBalance, ScenarioResultExtended } from "./types";
import { generateDividendEvents } from "./dividend-generator";

type Scenario = {
  name: string;
  events: Array<ScenarioEvent>;
};

type ScenarioEvent = {
  name: string;
  type: "income" | "expense";
  amount: number;
  unlockedBy: Array<CashflowConditions | BalanceConditions>;
  recurrence: { type: "once" | "monthly" | "yearly" };
  metadata?: Record<string, string>;
};

type CashflowConditions =
  | {
      tag: "cashflow";
      type: "date-is";
      value: LocalDate;
    }
  | {
      tag: "cashflow";
      type: "date-in-range";
      value: { start: LocalDate; end: LocalDate | null };
    };

type BalanceConditions =
  | {
      tag: "balance";
      type: "networth-is-above";
      value: { eventRef: string; amount: number };
    }
  | {
      tag: "balance";
      type: "event-happened";
      value: { eventName: string };
    }
  | {
      tag: "balance";
      type: "income-is-above";
      value: { eventName: string; amount: number };
    };

const makeScenario = (input: {
  name: string;
  events: Array<ScenarioEvent>;
}): Scenario => input;

const isSameMonthLD = (a: LocalDate, b: LocalDate): boolean =>
  a.y === b.y && a.m === b.m;

const isEventActiveInMonth = (
  monthStart: LocalDate,
  event: ScenarioEvent,
): boolean => {
  const cashflowConditions = event.unlockedBy.filter(
    (c) => c.tag === "cashflow",
  );
  const balanceConditions = event.unlockedBy.filter((c) => c.tag === "balance");

  // If event has balance conditions, don't evaluate in cashflow phase
  // It will be evaluated in balance phase
  if (balanceConditions.length > 0) {
    return false;
  }

  if (cashflowConditions.length === 0) {
    return false;
  }

  for (const cond of cashflowConditions) {
    switch (cond.type) {
      case "date-is": {
        if (!isSameMonthLD(monthStart, cond.value)) {
          return false;
        }
        break;
      }

      case "date-in-range": {
        const start = startOfMonthLD(cond.value.start);
        const end = cond.value.end
          ? startOfMonthLD(cond.value.end)
          : ld(2999, 12, 1);

        if (!isWithinIntervalLD(monthStart, { start, end })) {
          return false;
        }
        break;
      }
    }
  }

  switch (event.recurrence.type) {
    case "once": {
      // If conditions passed, "once" means the date-is condition must match.
      // But the "date-is" condition itself already ensures it only fires *that* month.
      // So if conditions passed above → true.
      return true;
    }

    case "monthly": {
      // If conditions passed, monthly means: fire every month
      // The date-in-range condition already constrains the time window.
      return true;
    }

    case "yearly": {
      // Fire only if the month matches the start month
      const dateRangeCond = event.unlockedBy.find(
        (c): c is Extract<CashflowConditions, { type: "date-in-range" }> =>
          c.type === "date-in-range",
      );

      if (!dateRangeCond) {
        // Yearly recurrence without a date range makes no sense → safe fallback
        return false;
      }

      const startMonth = dateRangeCond.value.start.m;
      // True on month anniversary
      return monthStart.m === startMonth;
    }
  }
};

type CashflowEntry = {
  amount: number;
  events: ScenarioEvent[];
};

type Cashflow = Record<string, CashflowEntry>;

const toCashflow = (input: {
  scenario: Scenario;
  startDate: LocalDate;
  endDate: LocalDate;
}): Cashflow => {
  const { scenario, startDate, endDate } = input;

  const cashflow: Cashflow = {};

  let currentMonth = startOfMonthLD(startDate);
  const finalMonth = startOfMonthLD(endDate);

  while (!isAfterLD(currentMonth, finalMonth)) {
    const key = toKeyMonth(currentMonth);
    cashflow[key] = { amount: 0, events: [] };

    // Evaluate active events for this month
    for (const event of scenario.events) {
      if (isEventActiveInMonth(currentMonth, event)) {
        const value = event.type === "income" ? event.amount : -event.amount;
        cashflow[key].amount += value;
        cashflow[key].events.push(event);
      }
    }

    currentMonth = addMonthsLD(currentMonth, 1);
  }

  return cashflow;
};

const toBalance = (input: {
  scenario: Scenario;
  cashflow: Cashflow;
  initialBalance: number;
}) => {
  const { scenario, cashflow, initialBalance } = input;

  const balance: Record<string, number> = {};
  const firedBalanceEvents = new Set<string>();
  const firedEventNames = new Set<string>();

  let runningBalance = initialBalance;

  const sortedMonths = Object.keys(cashflow).sort();

  for (const month of sortedMonths) {
    runningBalance += cashflow[month].amount;
    balance[month] = runningBalance;

    // Track which events fired this month (for event-happened condition)
    for (const event of cashflow[month].events) {
      firedEventNames.add(event.name);
    }

    for (const event of scenario.events) {
      // For one-off events, skip if already fired
      if (
        event.recurrence.type === "once" &&
        firedBalanceEvents.has(event.name)
      ) {
        continue;
      }

      const balanceConditions = event.unlockedBy.filter(
        (c) => c.tag === "balance",
      );
      const cashflowConditions = event.unlockedBy.filter(
        (c) => c.tag === "cashflow",
      );

      if (balanceConditions.length === 0) continue;

      // Parse current month from string (e.g., "2025-01")
      const [yearStr, monthStr] = month.split("-");
      const currentMonth = ld(parseInt(yearStr), parseInt(monthStr), 1);

      // Check cashflow conditions (date-based)
      const cashflowConditionsMet = cashflowConditions.every((cond) => {
        switch (cond.type) {
          case "date-is":
            return isSameMonthLD(currentMonth, cond.value);

          case "date-in-range": {
            const start = startOfMonthLD(cond.value.start);
            const end = cond.value.end
              ? startOfMonthLD(cond.value.end)
              : ld(2999, 12, 1);
            return isWithinIntervalLD(currentMonth, { start, end });
          }
        }
      });

      if (!cashflowConditionsMet) continue;

      // For recurring events, check recurrence pattern
      if (event.recurrence.type === "yearly") {
        const dateRangeCond = cashflowConditions.find(
          (c): c is Extract<CashflowConditions, { type: "date-in-range" }> =>
            c.type === "date-in-range",
        );
        if (dateRangeCond) {
          const startMonth = dateRangeCond.value.start.m;
          if (currentMonth.m !== startMonth) {
            continue;
          }
        }
      }

      // Check balance conditions
      const balanceConditionsMet = balanceConditions.every((cond) => {
        switch (cond.type) {
          case "networth-is-above":
            return runningBalance > cond.value.amount;

          case "event-happened":
            return firedEventNames.has(cond.value.eventName);

          case "income-is-above": {
            // Find the referenced income event in the current month's events
            const incomeEvent = cashflow[month].events.find(
              (e) => e.name === cond.value.eventName && e.type === "income",
            );
            return incomeEvent
              ? incomeEvent.amount >= cond.value.amount
              : false;
          }
        }
      });

      // If all conditions met and not already counted in this month, apply it
      if (balanceConditionsMet && !cashflow[month].events.includes(event)) {
        const value = event.type === "income" ? event.amount : -event.amount;
        cashflow[month].amount += value;
        cashflow[month].events.push(event);

        // Update running balance for the current month
        runningBalance += value;
        balance[month] = runningBalance;

        // Only track one-off events to prevent duplicate firing
        if (event.recurrence.type === "once") {
          firedBalanceEvents.add(event.name);
        }
        firedEventNames.add(event.name);
      }
    }
  }

  return balance;
};

const calculateAssetGrowth = (
  initialValue: number,
  monthlyRate: number,
  numMonths: number,
): number => {
  return initialValue * Math.pow(1 + monthlyRate, numMonths);
};

const runScenario = (input: {
  scenario: Scenario;
  startDate: LocalDate;
  endDate: LocalDate;
  initialBalance: number;
  portfolioAssets?: PortfolioAsset[];
  growthRate?: number;
  dividendYield?: number;
}): ScenarioResultExtended => {
  const {
    scenario,
    startDate,
    endDate,
    initialBalance,
    portfolioAssets = [],
    growthRate = 0.07,
    dividendYield = 0.02,
  } = input;

  // Convert annual rate to monthly
  const monthlyGrowthRate = Math.pow(1 + growthRate, 1 / 12) - 1;

  // Auto-generate dividend events from portfolio
  const dividendEvents = generateDividendEvents(
    portfolioAssets,
    dividendYield,
    startDate,
    endDate,
  );

  const extendedScenario = {
    ...scenario,
    events: [...scenario.events, ...dividendEvents],
  };

  const cashflow = toCashflow({
    scenario: extendedScenario,
    startDate,
    endDate,
  });

  const cashBalance = toBalance({
    scenario: extendedScenario,
    cashflow,
    initialBalance,
  });

  // Calculate asset growth month-by-month
  const assetBalance: Record<string, AssetBalance> = {};
  const totalBalance: Record<string, number> = {};
  const sortedMonths = Object.keys(cashBalance).sort();

  sortedMonths.forEach((month, index) => {
    assetBalance[month] = {};
    let totalAssetValue = 0;

    portfolioAssets.forEach((asset) => {
      const assetValue = calculateAssetGrowth(
        asset.initialValue,
        monthlyGrowthRate,
        index,
      );
      assetBalance[month][asset.id] = assetValue;
      totalAssetValue += assetValue;
    });

    totalBalance[month] = cashBalance[month] + totalAssetValue;
  });

  return {
    cashflow,
    cashBalance,
    assetBalance,
    totalBalance,
  };
};

const makeOneOff = (input: {
  type: "income" | "expense";
  name: string;
  amount: number;
  date: LocalDate;
  unlockedBy?: Array<CashflowConditions | BalanceConditions>;
}): ScenarioEvent => {
  return {
    type: input.type,
    amount: input.amount,
    name: input.name,
    recurrence: { type: "once" },
    unlockedBy: (input.unlockedBy ?? []).concat([
      { tag: "cashflow", type: "date-is", value: input.date },
    ]),
  };
};

const makeEvent = (input: {
  type: "income" | "expense";
  name: string;
  amount: number;
  unlockedBy: Array<CashflowConditions | BalanceConditions>;
}): ScenarioEvent => {
  return {
    type: input.type,
    amount: input.amount,
    name: input.name,
    recurrence: { type: "once" },
    unlockedBy: input.unlockedBy,
  };
};

const makeRecurring = (input: {
  type: "income" | "expense";
  name: string;
  amount: number;
  startDate: LocalDate;
  endDate: LocalDate | null;
  frequency: "monthly" | "yearly";
  unlockedBy?: Array<CashflowConditions | BalanceConditions>;
}): ScenarioEvent => {
  return {
    type: input.type,
    amount: input.amount,
    name: input.name,
    recurrence: { type: input.frequency },
    unlockedBy: (input.unlockedBy ?? []).concat([
      {
        tag: "cashflow",
        type: "date-in-range",
        value: { start: input.startDate, end: input.endDate },
      },
    ]),
  };
};

export {
  type Scenario,
  type ScenarioEvent,
  type Cashflow,
  type CashflowEntry,
  type PortfolioAsset,
  type ScenarioResultExtended,
  makeScenario,
  toCashflow,
  runScenario,
  makeOneOff,
  makeRecurring,
  makeEvent,
  isEventActiveInMonth,
  makeDependency,
};
